# Angular 2 Master Class - Notes
## Performance
- Angular Universal has to be enabled on server side (nodejs) -> serverside rendering
- One check change detection instead of possibly multiple digest loops
- Offline compilation possible -> activate during build

## Language
- Typescript has type inference, not necessary to define type of each variable. It will detect the type automatically.
- If there is a type which can't be infered the any type will be used. no implicit any setting in typescript will give an error when any is implicitly used. 
- Mostly use generic syntact `Array<number>`, because works with everthing.
- Types only available at compile time, not visible in source code. Is just plain ES5. 

## Bootstrapping
- Decorator is just transpiled to a function. What it does depends on the implementation of the decorator.
- `@Component` will only add metadata used by angular
  - `selector`: css selector which matches the html element
  - component is a directive with a view (component extends directive)
  - If template is at most 6 lines, can be done inline. Otherwise in separate file.
- `@NgModule`
  - adds metadata to the module class
  - `import`: import `BrowserModule` because the app needs to run in the browser, could also run in other things
  - `declaration`: all components, directives, pipes declared in the module
  - `bootstrap`: the component to bootstrap when the module is bootstrapped
  - `exports`: components, directives, pipes which will be available to other modules imorting you
- `platform-browser-dynamic`
  - a browser with compiler, if compiling is done in advance we need another platform
- Only add `BrowserModule` to your application root module. If you need *ngIf, *ngFor somewhere else and have lazy loaded modules then import `CommonsModule`.
  
## index.ts
- Was generated by older version of angular-cli to more easily import stuff, now not automatically created anymore.

## Data binding
- No more problems with scope inheritance. The execution context is always to component itself.

## Property binding
- Attributes are written in html, type of attribute is string. But we want to pass an object to a component/directive. This is where properties come in.
- Attributes are used to set initial value, properties can be changed at runtime
- Binding to properties allows angular 2 work with components build in other libraries, polymer. Every element has properties. In angular 1 scope was used to bind. Polymer doesnt know about scopes. This made integrating those components hard.
- `[...]` syntax is angular syntax -> when we use [], we expect an expression, so no {{}} needed
- best to be explicit and always use []
- binding to events can be done with `(event)`, can bind to any event

## *ngFor
- is a direcive which changes the dom
- `*` indicates that the element it is a template

## Services and DI
- put stuff in services which are independent of UI logic so it can be reused
- [always decorate](http://blog.thoughtram.io/angular/2015/09/17/resolve-service-dependencies-in-angular-2.html) with `@Injectable`
- `{ provide: ContactsService, useClass: ContactsService }`: when someone needs the token ContactService create a new instance of class ContactsService
- `ContactsService` in short
- Don't need to return a class, can also return a string
- With typescript we can inject it in the constructor, the type annotation will be used to deduce which dependency to inject,
- Tokens can only be string, type or function
- Angular 2 application is a tree of components, and thus a tree of injectors. When a component needs a dependency it first checks whether it has a provider for it. If not it will go up the tree to search for one. So services are singletons in there subtree.
- Providers can be defined on modules and components. Mostly we define them on modules.
- If there are multiple providers for the same service, the last one wins.
- When module B gets imported in module A, all the providers of module B will be merged with the providers of module A. But if they would have the same provider, then the one of module A wins.
- Feature modules shouldn't define providers. They should be shared across the application and be in some kind of shared/core module.

## Routing
-  `[routerLink]="['/contact', contact.id]"`: we apply the routerLink directive and write the array to the routerLink attribute of the routerLink directive.
- in routerLink directive leading slash for absolute url; in router configuration no leading slashes
- ui.router is also available for angular 2

## HTTP
- We dont want to import everything from rxjs, that's why we only import what we need. Place this in a root or shared/core module so it can be used in the entire app.
- Observables are lazy, they only get really executed when a terminal operator like subsribe is called.
- no ngResource

## Two way data binding
- `[(ngModel)]`: banana in a box, property binding on an event.
- `[(name)]` is shorthand for a property binding on the `name` + an event binding on `name`Change event

## String tokens
- Behind the scenes the type annotation Http which is used o inject http is translated to @Inject(Http)

## Links 
- [Angular 2](https://angular.io)
- [Thoughtam Gitter](https://gitter.im/thoughtram/cegeka)
- [Thougthtram GitHub](https://github.com/thoughtram)
- [Thoughtram NG2 Ecercises](https://github.com/thoughtram/angular2-master-class-exercise-descriptions)
- [Thoughtram Slides](http://classroom.thoughtram.io)
- [Thoughtram Blog](http://blog.thoughtram.io/)
- [Opaque Tokens](http://blog.thoughtram.io/angular/2016/05/23/opaque-tokens-in-angular-2.html)
- [Web Components](http://webcomponents.org/)
